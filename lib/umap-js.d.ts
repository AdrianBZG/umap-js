// Generated by dts-bundle v0.7.3

declare module 'umap' {
    import * as matrix from 'umap/matrix';
    export type DistanceFn = (x: Vector, y: Vector) => number;
    export type EpochCallback = (epoch: number) => boolean | void;
    export type Vector = number[];
    export type Vectors = Vector[];
    export const enum TargetMetric {
        categorical = "categorical",
        l1 = "l1",
        l2 = "l2"
    }
    export interface UMAPParameters {
        minDist?: number;
        nComponents?: number;
        nEpochs?: number;
        nNeighbors?: number;
        random?: () => number;
        spread?: number;
    }
    export interface UMAPSupervisedParams {
        targetMetric?: TargetMetric;
        targetWeight?: number;
        targetNNeighbors?: number;
    }
    export class UMAP {
        constructor(params?: UMAPParameters);
        fit(X: Vectors): number[][];
        fitAsync(X: Vectors, callback?: (epochNumber: number) => void | boolean): Promise<number[][]>;
        setSupervisedProjection(Y: number[], params?: UMAPSupervisedParams): void;
        setPrecomputedKNN(knnIndices: number[][], knnDistances: number[][]): void;
        initializeFit(X: Vectors): number;
        step(): number;
        getEmbedding(): number[][];
    }
    export function euclidean(x: Vector, y: Vector): number;
    export function cosine(x: Vector, y: Vector): number;
    export function findABParams(spread: number, minDist: number): {
        a: number;
        b: number;
    };
    export function fastIntersection(graph: matrix.SparseMatrix, target: number[], unknownDist?: number, farDist?: number): matrix.SparseMatrix;
    export function resetLocalConnectivity(simplicialSet: matrix.SparseMatrix): matrix.SparseMatrix;
}

declare module 'umap/matrix' {
    export class SparseMatrix {
        readonly nRows: number;
        readonly nCols: number;
        constructor(rows: number[], cols: number[], values: number[], dims: number[]);
        set(row: number, col: number, value: number): void;
        get(row: number, col: number, defaultValue?: number): number;
        getDims(): number[];
        getRows(): number[];
        getCols(): number[];
        getValues(): number[];
        forEach(fn: (value: number, row: number, col: number) => void): void;
        map(fn: (value: number, row: number, col: number) => number): SparseMatrix;
        toArray(): number[][];
    }
    export function transpose(matrix: SparseMatrix): SparseMatrix;
    export function identity(size: number[]): SparseMatrix;
    export function pairwiseMultiply(a: SparseMatrix, b: SparseMatrix): SparseMatrix;
    export function add(a: SparseMatrix, b: SparseMatrix): SparseMatrix;
    export function subtract(a: SparseMatrix, b: SparseMatrix): SparseMatrix;
    export function multiplyScalar(a: SparseMatrix, scalar: number): SparseMatrix;
    export function eliminateZeros(m: SparseMatrix): SparseMatrix;
    export function normalize(m: SparseMatrix, normType?: NormType): SparseMatrix;
    export const enum NormType {
        max = "max",
        l1 = "l1",
        l2 = "l2"
    }
}

